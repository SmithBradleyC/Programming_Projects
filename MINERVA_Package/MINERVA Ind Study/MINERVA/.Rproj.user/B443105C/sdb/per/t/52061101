{
    "collab_server" : "",
    "contents" : "##################################################################################################################################################################\n##################################################################################################################################################################\n##################################################################################################################################################################\n# make sure number of items is always even so that we can always evenly split it in half\n##################################################################################################################################################################\n##################################################################################################################################################################\n##################################################################################################################################################################\n\n\n\n##################################################################################################################################################################\n\n# Make each instance by randomly generating a string of items that are either -1 or 1\nmake_instance<-function(num_items=20){\n  return(c((2*rbern(num_items,0.5)-1)))\n}\n\n##################################################################################################################################################################\n\n# add a row to memory\nadd_to_memory<-function(instance,\n                        memory,\n                        L=1,\n                        times = 1){\n  \n  for (i in 1:times){\n  \n  \n  # add the instance to memory\n  memory<-rbind(memory,instance)\n  \n  # Forget each feature in the added instance with probability 1-L\n  count<-1\n  for (i in instance){\n    memory[nrow(memory),count]<-i*(rbern(1,L))\n    count<-count+1\n  }\n  }\n  # avoid naming rows\n  row.names(memory)<-NULL\n  return(memory)\n}\n\n##################################################################################################################################################################\n\nforget_in_memory<-function(memory,\n                 L=.25){\n  for (i in 1:length(memory)){\n    memory[i]<-memory[i]*(rbern(1,L))\n  }\n  return(memory)\n}\n\n##################################################################################################################################################################\n\n# make an empty matrix for memory to be added in\ninitiate_memory<-function(num_items=20){\n  return(matrix(ncol = num_items,nrow = 0))\n}\n\n##################################################################################################################################################################\n\n# make a probe matrix from \nmake_probe_matrix<-function(test_instances,\n                       \n                       # assume just probing one but option to test several\n                       num_instances_to_probe = 1){\n  return(matrix(test_instances,ncol = num_instances_to_probe))\n}\n\n##################################################################################################################################################################\n\nget_divide_matrix<-function(memory,\n                            probe){\n  \n  # make a matrix as large as the resulting intensities matrix and fill it with the max relevant n's\n  divide<-matrix(data = c(rep(ncol(memory),(nrow(memory)*ncol(probe)))),byrow = TRUE,ncol = ncol(probe))\n  \n  # for each probe\n  count_probe<-0\n  while (count_probe < ncol(probe)){\n    count_probe<-count_probe+1\n    \n    # for each row in memory\n    count_row<-0\n    while (count_row < nrow(memory)){\n      count_row<-count_row+1\n      \n      # for each item in that row in memory\n      count_col<-0\n      while (count_col < ncol(memory)){\n        count_col<-count_col+1\n        \n        # if both the item in memory and the item in the probe are 0 then subtract 1 from the proper spot in the divide matrix\n        if (memory[count_row,count_col]==0){\n          if (probe[count_col,count_probe]==0){\n            divide[count_row,count_probe]<-divide[count_row,count_probe]-1\n          }\n        }\n      }\n      \n    }\n  }\n  \n  # returns a matrix of values that the make up the denominator for the similarity of the traces\n  return(divide)\n}\n\n##################################################################################################################################################################\n\nget_similarity<-function(memory,\n                         probe,\n                         divide = get_divide_matrix(memory,probe)){\n  \n  # get the numerator of the similarity\n  similarity<-memory%*%probe\n  \n  # divide each similarity numerator by the denominator calculated in divide_matrix()\n  count<-0\n  while (count < nrow(similarity)*ncol(similarity)){\n    count<-count+1\n    similarity[count]<-similarity[count]/divide[count]\n  }\n  return(similarity)\n}\n\n##################################################################################################################################################################\n\n# cube each iten the the similarity matrix so that relevant items have more influence than less relevant items\nget_activation<-function(similarity){\n  return(similarity^3)\n}\n\n##################################################################################################################################################################\n\n# sum the columns of the activation matrix to get a measure of intensity (how \"familiar\" is the probe i)\nget_intensity<-function(activation){\n  return(colSums(activation))\n}\n\n##################################################################################################################################################################\n\n# get the content of the echo\nget_echo<-function(activation,\n                   memory,\n                   type = \"normed\",\n                   rounding_digits = 0){\n  \n  good_type_input<-type%in%c(\"raw\",\"normed\",\"rounded\")\n  if (good_type_input == F){stop(\"Improper echo type specified\")}\n  \n  # get the echo by multiplying the activation matrix by the memory\n  echo<-t(activation)%*%memory\n  \n  # if the user asks for the raw echo then return it\n  if (type == \"raw\"){return(echo)}\n  \n  # normalize the echo by dividing each number in an instance by the largest number in that instance\n  normed_echo<-echo\n  nrow<-0\n  while (nrow < nrow(normed_echo)){\n    nrow<-nrow+1\n    normed_echo[nrow,]<-normed_echo[nrow,]/max(abs(normed_echo[nrow,]))\n  }\n  \n  # if the user asks for the normed echo (default setting) then return it\n  if (type == \"normed\"){return(normed_echo)}\n  \n  # if the user asks for the rounded echo then return the rounded normed echo (default is to 0 sig digits for whole numbers comparison with probe)\n  if(type == \"rounded\"){return(round(normed_echo,digits = rounding_digits))}\n  \n}\n\n##################################################################################################################################################################\n\nadd_distortion<-function(instance,\n                         proportion = 0.3,\n                         name_first = T){\n  len<-round(length(instance)/2,0)\n  number_to_distort<-round(len*proportion,0)\n  distort_list<-c()\n  repeat{\n    new_num<-round(runif(1,1,len),0)\n    if (new_num %in% distort_list){} # do nothing\n    else{\n      distort_list<-c(distort_list,new_num)\n    }\n    if (length(distort_list)==number_to_distort){\n      break\n    }\n  }\n\n  if (name_first == T){\n    distort_list<-distort_list+len\n  }\n\n  for (i in distort_list){\n    instance[i]<-(-1)*instance[i]\n  }\n\n  return(instance)\n}\n\n##################################################################################################################################################################\n\ncorrelate_echo_names<-function(echo,\n                               category,\n                               name_first = T){\n  len<-round(length(echo)/2,0)\n  if (name_first == F){return(cor(echo[len+1:length(echo)],category[len+1:length(echo)]))}\n  else{return(cor(echo[1:len],category[1:len]))}\n}\n\n##################################################################################################################################################################\n##################################################################################################################################################################\n\nschema_abstraction<-function(n_participants = 50,\n                             num_items =20,\n                             distortion_proportion = 0.3,\n                             name_first = T,\n                             number_of_categories = 3,\n                             # list specifying number in each category\n                             frequency_of_categories = c(30,40,60),\n                             number_of_distractors = 0,\n                             forget_proportion = 0.75,\n                             present_names = T,\n                             type = \"normed\",\n                             ...){\n  \n  # for when you want to do the follow up test with forgetting\n  L = 1-forget_proportion\n  \n  # if the parameters don't match up flag error\n  if (number_of_categories != length(frequency_of_categories)){stop(\"Must specify how many instances in each category\")}\n  \n  # initiate memory\n  memory<-initiate_memory(num_items = num_items)\n  \n  \n  \n  # make a matrix to store the prototypes in to remember later\n  prototype_matrix<-matrix(ncol = num_items,nrow = 0)\n  for (i in 1:number_of_categories){\n    prototype<-make_instance(num_items = num_items)\n    prototype_matrix<-rbind(prototype_matrix,prototype)\n  \n    for (y in 1:frequency_of_categories[i]){\n      memory<-add_to_memory(add_distortion(instance = prototype,\n                                           proportion = distortion_proportion,\n                                           name_first = T),\n                            memory = memory)\n    }\n  }\n  #distractor<-make_instance(num_items = num_items)\n  #prototype_matrix<-rbind(prototype_matrix,distractor)\n  rownames(prototype_matrix)<-NULL\n  \n  # make a probe matrix for testing\n  probe<-c()\n  \n  if (present_names == T){\n    distractor<-make_instance(num_items = num_items)\n    prototype_matrix<-rbind(prototype_matrix,distractor)\n    rownames(prototype_matrix)<-NULL\n    probe<-prototype_matrix\n\n    \n    for (i in (num_items/2+1):num_items){\n      probe[,i]<-c(rep(0,nrow(probe)))\n    }\n    \n    names<-c()\n    for (i in 1:number_of_categories){\n      names<-c(names,paste(\"Prototype \",i))\n    }\n    names_col<-c(names,\"Distractor\")\n    names_row<-c(\"Prototype\", \"Probe\", \"Echo\", \"Intensity\")\n    number_of_rows<-number_of_categories+1\n\n    \n    \n  }\n  if (present_names == F){\n    \n    # get an exemplar that had been stored for each prototype for the probe matrix\n    for (i in 1:number_of_categories){\n      exemplar<-memory[sum(frequency_of_categories[1:i]),]\n      probe<-c(probe,exemplar,prototype_matrix[i,],add_distortion(prototype_matrix[i,],proportion = distortion_proportion,name_first = name_first))\n    }\n    probe<-c(probe,make_instance(num_items = num_items))\n    probe<-matrix(probe,ncol=num_items,byrow = TRUE)\n    prototype_matrix<-probe\n    #prototype_matrix<-rbind(probe,make_instance(num_items = num_items))\n    #print(prototype_matrix)\n    \n    \n    for (i in 1:(num_items/2)){\n      probe[,i]<-c(rep(0,nrow(probe)))\n    }\n    \n    names<-c()\n    for (i in 1:number_of_categories){\n      names<-c(names,paste(\"Prototype \",i,\" (Exemplary in memory)\"),\"Prototype\",\"New Exemplar\")\n    }\n    names_col<-c(names,\"Distractor\")\n    names_row<-c(\"Prototype \", \"Probe\", \"Echo\", \"Intensity\")\n    number_of_rows<-nrow(prototype_matrix)\n    \n    \n    \n  }\n  \n\n  similarity<-get_similarity(memory,t(probe))\n  activation<-get_activation(similarity)\n  intensity<-get_intensity(activation)\n  echo<-get_echo(activation, memory,type = type)\n\n  \n  # format data for output\n  prototype_text<-apply(format(prototype_matrix),1,paste,collapse=\",\")\n  probe_text<-apply(format(probe), 1, paste, collapse=\",\")\n  # round_normed_echo_text<-apply(format(round(normed_echo,digits = 0)), 1, paste, collapse=\",\")\n  # normed_echo_text<-apply(format(round(normed_echo,digits = 2)), 1, paste, collapse=\",\")\n  echo_text<-apply(format(round(echo,digits = 2)), 1, paste, collapse=\",\")\n  # \n  echo_text\n  \n  print(as.table(matrix(c(prototype_text,probe_text,echo_text, round(intensity,digits = 3)), \n                   nrow = number_of_rows, byrow = FALSE, \n                   dimnames = list(names_col,names_row))))\n  # \n  \n  \n  \n  # print(echo)\n  # print(intensity)\n  # similarity\n  # activation\n  # intensity\n  # echo\n }\n \n# sum(x[1,]==memory[30,]) == 20\n# sum(x[2,]==prototype_matrix[1,]) == 20\n# sum(x[3,]==prototype_matrix[1,])== 17\n# (x[4,])\n# sum(x[5,]==memory[70,])== 20\n# sum(x[6,]==prototype_matrix[2,])== 20\n# sum(x[7,]==prototype_matrix[2,])== 17\n# (x[8,])\n# sum(x[9,]==memory[130,])== 20\n# sum(x[10,]==prototype_matrix[3,])== 20\n# (sum(x[11,]==prototype_matrix[3,]))== 17\n# x[12,]\n\n}\n\n\n##################################################################################################################################################################\n# Libraries needed\nlibrary(LaplacesDemon)\n\n# The number of items that each instance will have\nnum_items<-20\n\n# The number of distractor items\nnum_distractors<-500\n\n# The learning rate variable. Each individaul item in each instance has an L chance of being remembered. Otherwise =0\nL<-0.75\n\n# How many instances of each target item will be made\nitem1_rep<-9\nitem2_rep<-6\nitem3_rep<-3\n##################################################################################################################################################################\n\n\nintensity<-0\nL<-1\nfor (i in 1:100){\n#intensity<-0\nmemory<-initiate_memory()\nmemory<-add_to_memory(make_instance(),memory,L = L,times = 9)\nmemory<-add_to_memory(make_instance(),memory,L = L,times = 6)\nmemory<-add_to_memory(make_instance(),memory,L = L,times = 3)\nfor (i in 1:100){\n  memory<-add_to_memory(make_instance(),memory,L = L)\n}\n\nprobe<-make_probe_matrix(c(memory[1,],memory[10,],memory[16,],make_instance()),4)\nsimilarity<-get_similarity(memory,probe)\nactivation<-get_activation(similarity)\nintensity<-intensity+get_intensity(activation)\nintensity\n#get_echo(activation,memory,\"rounded\")\n#t(probe)\n#intensity\n}\nintensity/100\n\n\n\n\n\n",
    "created" : 1486414191693.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "697934935",
    "id" : "52061101",
    "lastKnownWriteTime" : 1486426518,
    "last_content_update" : 1486426518077,
    "path" : "~/Dropbox/Bradley/MINERVA Ind Study/MINERVA/MINERVA2_separate functions.R",
    "project_path" : "MINERVA2_separate functions.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}