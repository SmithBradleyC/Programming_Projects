{
    "collab_server" : "",
    "contents" : "##################################################################################################################################################################\n##################################################################################################################################################################\n##################################################################################################################################################################\n# make sure number of items is always even so that we can always evenly split it in half\n##################################################################################################################################################################\n##################################################################################################################################################################\n##################################################################################################################################################################\n\n#Libraries Needed\nlibrary(LaplacesDemon)\n\n##################################################################################################################################################################\n\n# Make each instance by randomly generating a string of items that are either -1 or 1\nmake_instance<-function(num_items=20){\n  return(c((2*rbern(num_items,0.5)-1)))\n}\n\n##################################################################################################################################################################\n\n# add a row to memory\nadd_to_memory<-function(instance,\n                        memory,\n                        L=1,\n                        times = 1){\n  \n  for (i in 1:times){\n  \n  \n  # add the instance to memory\n  memory<-rbind(memory,instance)\n  \n  # Forget each feature in the added instance with probability 1-L\n  count<-1\n  for (i in instance){\n    memory[nrow(memory),count]<-i*(rbern(1,L))\n    count<-count+1\n  }\n  }\n  # avoid naming rows\n  row.names(memory)<-NULL\n  return(memory)\n}\n\n##################################################################################################################################################################\n\nforget_in_memory<-function(memory,\n                 L=.25){\n  for (i in 1:length(memory)){\n    memory[i]<-memory[i]*(rbern(1,L))\n  }\n  return(memory)\n}\n\n##################################################################################################################################################################\n\n# make an empty matrix for memory to be added in\ninitiate_memory<-function(num_items=20){\n  return(matrix(ncol = num_items,nrow = 0))\n}\n\n##################################################################################################################################################################\n\n# make a probe matrix from \nmake_probe_matrix<-function(test_instances,\n                       \n                       # assume just probing one but option to test several\n                       num_instances_to_probe = 1){\n  return(matrix(test_instances,ncol = num_instances_to_probe))\n}\n\n##################################################################################################################################################################\n\nget_divide_matrix<-function(memory,\n                            probe){\n  \n  # make a matrix as large as the resulting intensities matrix and fill it with the max relevant n's\n  divide<-matrix(data = c(rep(ncol(memory),(nrow(memory)*ncol(probe)))),byrow = TRUE,ncol = ncol(probe))\n  \n  # for each probe\n  count_probe<-0\n  while (count_probe < ncol(probe)){\n    count_probe<-count_probe+1\n    \n    # for each row in memory\n    count_row<-0\n    while (count_row < nrow(memory)){\n      count_row<-count_row+1\n      \n      # for each item in that row in memory\n      count_col<-0\n      while (count_col < ncol(memory)){\n        count_col<-count_col+1\n        \n        # if both the item in memory and the item in the probe are 0 then subtract 1 from the proper spot in the divide matrix\n        if (memory[count_row,count_col]==0){\n          if (probe[count_col,count_probe]==0){\n            divide[count_row,count_probe]<-divide[count_row,count_probe]-1\n          }\n        }\n      }\n      \n    }\n  }\n  \n  # returns a matrix of values that the make up the denominator for the similarity of the traces\n  return(divide)\n}\n\n##################################################################################################################################################################\n\nget_divide_matrix_cosine<-function(memory,\n                                   probe){\n  probe2<-(probe^2)\n  memory2<-(memory^2)\n  \n  # this might screw things up ###############\n  sum_memory_rows<-sum(memory2)\n  try(sum_memory_rows<-rowSums(memory2))\n\n  # this might make problems if probing 2 things at once\n  sum_probe_columns<-sum(probe2)\n  divide<-c()\n  for (i in sum_memory_rows){\n    for (j in sum_probe_columns){\n      divide<-c(divide,sqrt(i)*sqrt(j))\n    }\n  }\n  if (nrow(memory) == 0) {return(matrix(c(1),nrow = 1))}\n  return(matrix(divide,nrow = length(sum_memory_rows),byrow = TRUE))\n}\n\n##################################################################################################################################################################\n\nget_similarity<-function(memory,\n                         probe,\n                         cosine = FALSE,\n                         divide = NULL){\n  if (is.null(divide)){\n    if (cosine == TRUE){\n      divide = get_divide_matrix_cosine(memory,probe)\n    }\n    else {\n      divide = get_divide_matrix(memory,probe)\n    }\n  }\n  # get the numerator of the similarity\n  try(similarity<-memory%*%probe,silent = F)\n  \n  if (nrow(memory)==0){similarity<-matrix(c(0),nrow = 1)}\n\n  # divide each similarity numerator by the denominator calculated in divide_matrix()\n  count<-0\n  while (count < nrow(similarity)*ncol(similarity)){\n    count<-count+1\n    similarity[count]<-similarity[count]/divide[count]\n  }\n  return(similarity)\n}\n\n##################################################################################################################################################################\n\n# cube each iten the the similarity matrix so that relevant items have more influence than less relevant items\nget_activation<-function(similarity){\n  return(similarity^3)\n}\n\n##################################################################################################################################################################\n\n# sum the columns of the activation matrix to get a measure of intensity (how \"familiar\" is the probe i)\nget_intensity<-function(activation){\n  return(colSums(activation))\n}\n\n##################################################################################################################################################################\n\n# get the content of the echo\nget_echo<-function(activation,\n                   memory,\n                   type = \"normed\",\n                   rounding_digits = 0){\n  \n  good_type_input<-type%in%c(\"raw\",\"normed\",\"rounded\")\n  if (good_type_input == F){stop(\"Improper echo type specified\")}\n  \n  if (nrow(memory)==0){return(matrix(rep(0,ncol(memory)),nrow = 1))}\n  \n  \n  # get the echo by multiplying the activation matrix by the memory\n  echo<-t(activation)%*%memory\n  \n  # if the user asks for the raw echo then return it\n  if (type == \"raw\"){return(echo)}\n  \n  # normalize the echo by dividing each number in an instance by the largest number in that instance\n  normed_echo<-echo\n  nrow<-0\n  while (nrow < nrow(normed_echo)){\n    nrow<-nrow+1\n    normed_echo[nrow,]<-normed_echo[nrow,]/max(abs(normed_echo[nrow,]))\n  }\n  \n  # if the user asks for the normed echo (default setting) then return it\n  if (type == \"normed\"){return(normed_echo)}\n  \n  # if the user asks for the rounded echo then return the rounded normed echo (default is to 0 sig digits for whole numbers comparison with probe)\n  if(type == \"rounded\"){return(round(normed_echo,digits = rounding_digits))}\n  \n}\n\n##################################################################################################################################################################\n\nadd_noise<-function(echo){\n  for (i in 1:length(echo)){\n    echo[i]<-echo[i]+runif(1,-0.001,0.001)\n  }\n  return(echo)\n}\n\n##################################################################################################################################################################\n\nadd_distortion<-function(instance,\n                         proportion = 0.3,\n                         name_first = T){\n  len<-round(length(instance)/2,0)\n  number_to_distort<-round(len*proportion,0)\n  distort_list<-c()\n  repeat{\n    new_num<-round(runif(1,1,len),0)\n    if (new_num %in% distort_list){} # do nothing\n    else{\n      distort_list<-c(distort_list,new_num)\n    }\n    if (length(distort_list)==number_to_distort){\n      break\n    }\n  }\n\n  if (name_first == T){\n    distort_list<-distort_list+len\n  }\n\n  for (i in distort_list){\n    instance[i]<-(-1)*instance[i]\n  }\n\n  return(instance)\n}\n\n##################################################################################################################################################################\n\ncorrelate_echo_names<-function(echo,\n                               category,\n                               name_first = T){\n  len<-round(length(echo)/2,0)\n  if (name_first == F){return(cor(echo[len+1:length(echo)],category[len+1:length(echo)]))}\n  else{return(cor(echo[1:len],category[1:len]))}\n}\n\n##################################################################################################################################################################\n##################################################################################################################################################################\n\nschema_abstraction<-function(n_participants = 50,\n                             num_items =40,\n                             distortion_proportion = 0.3,\n                             name_first = T,\n                             number_of_categories = 3,\n                             # list specifying number in each category\n                             frequency_of_categories = c(10,50,100),\n                             number_of_distractors = 0,\n                             forget_proportion = 0.75,\n                             present_names = T,\n                             type = \"normed\",\n                             sig_digits = 2,\n                             ...){\n  \n  # for when you want to do the follow up test with forgetting\n  L = 1-forget_proportion\n  \n  # if the parameters don't match up flag error\n  if (number_of_categories != length(frequency_of_categories)){stop(\"Must specify how many instances in each category\")}\n  \n  # make a matrix to store the prototypes in to remember later\n  prototype_matrix<-matrix(ncol = num_items,nrow = 0)\n  for (i in 1:number_of_categories){\n    prototype<-make_instance(num_items = num_items)\n    prototype_matrix<-rbind(prototype_matrix,prototype)\n  }\n  \n  # set up items to be able to average intensity and echo over participants\n  t_intensity<-0\n  t_echo<-0\n  \n  # repeat experiment with same prototypes over several participants\n  for (par in 1:n_participants){\n  \n  # initiate memory\n  memory<-initiate_memory(num_items = num_items)\n  \n  for (i in 1:number_of_categories){\n    prototype<-prototype_matrix[i,]\n    for (y in 1:frequency_of_categories[i]){\n      memory<-add_to_memory(add_distortion(instance = prototype,\n                                           proportion = distortion_proportion,\n                                           name_first = name_first),\n                            memory = memory)\n    }\n  }\n  #distractor<-make_instance(num_items = num_items)\n  #prototype_matrix<-rbind(prototype_matrix,distractor)\n  rownames(prototype_matrix)<-NULL\n  \n  # make a probe matrix for testing\n  probe<-c()\n  \n  if (present_names == T){\n    distractor<-make_instance(num_items = num_items)\n    #prototype_matrix<-rbind(prototype_matrix,distractor)\n    #rownames(prototype_matrix)<-NULL\n    probe<-prototype_matrix\n    probe<-rbind(probe,distractor)\n    rownames(probe)<-NULL\n\n    \n    for (i in (num_items/2+1):num_items){\n      probe[,i]<-c(rep(0,nrow(probe)))\n    }\n    \n    names<-c()\n    for (i in 1:number_of_categories){\n      names<-c(names,paste(\"Prototype \",i))\n    }\n    names_col<-c(names,\"Distractor\")\n    names_row<-c(\"Prototype\", \"Probe\", \"Echo\", \"Intensity\")\n    number_of_rows<-number_of_categories+1\n\n    \n    \n  }\n  if (present_names == F){\n    \n    # get an exemplar that had been stored for each prototype for the probe matrix\n    for (i in 1:number_of_categories){\n      exemplar<-memory[sum(frequency_of_categories[1:i]),]\n      probe<-c(probe,exemplar,prototype_matrix[i,],add_distortion(prototype_matrix[i,],proportion = distortion_proportion,name_first = name_first))\n    }\n    probe<-c(probe,make_instance(num_items = num_items))\n    probe<-matrix(probe,ncol=num_items,byrow = TRUE)\n    prototype_matrix<-probe\n    #prototype_matrix<-rbind(probe,make_instance(num_items = num_items))\n    #print(prototype_matrix)\n    \n    \n    for (i in 1:(num_items/2)){\n      probe[,i]<-c(rep(0,nrow(probe)))\n    }\n    \n    names<-c()\n    for (i in 1:number_of_categories){\n      names<-c(names,paste(\"Prototype \",i,\" (Exemplary in memory)\"),\"(Prototype)\",\"(New Exemplar)\")\n    }\n    names_col<-c(names,\"Distractor\")\n    names_row<-c(\"Prototype \", \"Probe\", \"Echo\", \"Intensity\")\n    number_of_rows<-nrow(prototype_matrix)\n    \n    \n    \n  }\n  \n#print(memory)\n#print(t(probe))\n  similarity<-get_similarity(memory,t(probe))\n  activation<-get_activation(similarity)\n  #print(activation)\n\n  intensity<-get_intensity(activation)\n  echo<-get_echo(activation, memory,type = type)\n  \n  # sum up total intensity and echo\n  t_intensity<-t_intensity+intensity\n  t_echo<-t_echo+echo\n\n  }\n  \n  # average out intensity and echo\n  a_intensity<-t_intensity/n_participants\n  a_echo<-t_echo/n_participants\n  \n  # format data for output\n  if (present_names == T){prototype_text<-apply(format(rbind(prototype_matrix,distractor)),1,paste,collapse=\",\")}\n  else{prototype_text<-apply(format(prototype_matrix),1,paste,collapse=\",\")}\n  probe_text<-apply(format(probe), 1, paste, collapse=\",\")\n  # round_normed_echo_text<-apply(format(round(normed_echo,digits = 0)), 1, paste, collapse=\",\")\n  # normed_echo_text<-apply(format(round(normed_echo,digits = 2)), 1, paste, collapse=\",\")\n  echo_text<-apply(format(round(a_echo,digits = sig_digits)), 1, paste, collapse=\",\")\n\n  \n  return(as.table(matrix(c(prototype_text,probe_text,echo_text, round(a_intensity,digits = 3)), \n                   nrow = number_of_rows, byrow = FALSE, \n                   dimnames = list(names_col,names_row))))\n  # \n  \n  \n  \n  # print(echo)\n  # print(intensity)\n  # similarity\n  # activation\n  # intensity\n  # echo\n }\n \n# sum(x[1,]==memory[30,]) == 20\n# sum(x[2,]==prototype_matrix[1,]) == 20\n# sum(x[3,]==prototype_matrix[1,])== 17\n# (x[4,])\n# sum(x[5,]==memory[70,])== 20\n# sum(x[6,]==prototype_matrix[2,])== 20\n# sum(x[7,]==prototype_matrix[2,])== 17\n# (x[8,])\n# sum(x[9,]==memory[130,])== 20\n# sum(x[10,]==prototype_matrix[3,])== 20\n# (sum(x[11,]==prototype_matrix[3,]))== 17\n# x[12,]\n\n\n\n##################################################################################################################################################################\n# # Libraries needed\n# library(LaplacesDemon)\n# \n# # The number of items that each instance will have\n# num_items<-20\n# \n# # The number of distractor items\n# num_distractors<-500\n# \n# # The learning rate variable. Each individaul item in each instance has an L chance of being remembered. Otherwise =0\n# L<-0.75\n# \n# # How many instances of each target item will be made\n# item1_rep<-9\n# item2_rep<-6\n# item3_rep<-3\n##################################################################################################################################################################\n\n\n# intensity<-0\n# L<-1\n# for (i in 1:100){\n# #intensity<-0\n# memory<-initiate_memory()\n# memory<-add_to_memory(make_instance(),memory,L = L,times = 9)\n# memory<-add_to_memory(make_instance(),memory,L = L,times = 6)\n# memory<-add_to_memory(make_instance(),memory,L = L,times = 3)\n# for (i in 1:100){\n#   memory<-add_to_memory(make_instance(),memory,L = L)\n# }\n# \n# probe<-make_probe_matrix(c(memory[1,],memory[10,],memory[16,],make_instance()),4)\n# similarity<-get_similarity(memory,probe)\n# activation<-get_activation(similarity)\n# intensity<-intensity+get_intensity(activation)\n# intensity\n# #get_echo(activation,memory,\"rounded\")\n# #t(probe)\n# #intensity\n# }\n# intensity/100\n\n##################################################################################################################################################################\n\n\n\n##################################################################################################################################################################\n\nsim_x<-function(event,\n                n_echo){\n  num<-0\n  p<-0\n  m<-0\n  for (i in 101:120){\n    num<-num+(event[i]*n_echo[i])\n    p<-p+(event[i]^2)\n    m<-m+(n_echo[i]^2)\n  }\n  #return(num/20)\n  return(num/(sqrt(p)*sqrt(m)))\n}\n\n\nsim_a<-function(event,\n                n_echo){\n  num<-0\n  p<-0\n  m<-0\n  for (i in 1:20){\n    num<-num+(event[i]*n_echo[i])\n    #p<-p+(event[i]^2)\n    #m<-m+(n_echo[i]^2)\n  }\n  return(num/20)\n  #return(num/(sqrt(p)*sqrt(m)))\n}\n\n\n##################################################################################################################################################################\n# test accuisition\n\n# A<-matrix(c(rep(1,20),rep(0,100)),nrow = 1)\n# X<-matrix(c(rep(0,100),rep(1,20)),nrow = 1)\n# C<-matrix(c(rep(0,80),rep(1,20),rep(0,20)),nrow = 1)\n# AX<-A+X+C\n# A<-A+C\n# X<-X+C\n# recall_list<-c()\n# learn<-1/3\n# sub<-25\n# for (k in 1:sub){\n#   memory<-initiate_memory(120)\n#   for (i in 1:100){\n#     s<-get_similarity(matrix(memory[,1:100],nrow = nrow(memory)),AX[,1:100],cosine = TRUE)\n#     a<-get_activation(s)\n#     e<-get_echo(a,memory)\n#     e<-add_noise(e)\n#     memory<-add_to_memory(AX-e,memory,L=learn)\n#     s<-get_similarity(matrix(memory[,1:100],nrow = nrow(memory)),AX[,1:100],cosine = TRUE)\n#     a<-get_activation(s)\n#     e<-get_echo(a,memory)\n#     recall_list<-c(recall_list,sim_a(X[101:120],e[101:120]))\n#   }\n#   for (i in 1:1){\n#     s<-get_similarity(matrix(memory[,1:100],nrow = nrow(memory)),A[,1:100],cosine = TRUE)\n#     a<-get_activation(s)\n#     e<-get_echo(a,memory)\n#     e<-add_noise(e)\n#     memory<-add_to_memory(A-e,memory,L=learn)\n#     s<-get_similarity(matrix(memory[,1:100],nrow = nrow(memory)),A[,1:100],cosine = TRUE)\n#     a<-get_activation(s)\n#     e<-get_echo(a,memory)\n#     recall_list<-c(recall_list,sim_a(X[101:120],e[101:120]))\n#   }\n# }\n# \n# recall<-matrix(recall_list,nrow = sub,byrow = TRUE)\n# recall2<-colSums(recall)/sub\n# \n# plot(1:length(recall2),recall2,ylim = c(0,1))\n\n##################################################################################################################################################################\n\nnew_similarity<-function(new_memory,probe){\n  num_sum<-0\n  den_sum1<-0\n  den_sum2<-0\n  for (i in 1:length(probe)){\n    num_sum<-num_sum+(new_memory[i]*probe[i])\n    den_sum1<-den_sum1+(new_memory[i]^2)\n    den_sum2<-den_sum2+(probe[i]^2)\n  }\n  den<-sqrt(den_sum1)*sqrt(den_sum2)\n  return(num_sum/den)\n}\n\n##################################################################################################################################################################\n# test accuisition for robot\n\n# set up 4 types of stimuli\nA<-matrix(c(rep(1,20),rep(0,60)),nrow = 1)\nX<-matrix(c(rep(0,60),rep(1,20)),nrow = 1)\nC<-matrix(c(rep(0,20),rep(1,20),rep(0,40)),nrow = 1)\ncon<-matrix(c(rep(0,40),rep(1,20),rep(0,20)),nrow = 1)\n# light on turn right\nAR<-A+C\n# light on turn left\nAL<-A-C\n# light off turn right\nOR<-C+con\n# light off turn left\nOL<-(-C)+con\nlearn<-4/10\nsub<-1\n\n# light is always true for now\n#light<- TRUE\n\n# make a list of turns and empty new_memory and recall\nturns<-c() # 1 means right, -1 means left choice\nrecall_list<-c()\nnew_memory<-NULL\nsim_R<-0\nsim_L<-0\nsim_r_list<-c()\nsim_l_list<-c()\nlights<-c(1)\n\n\nfor (k in 1:sub){\n  \n# empty the echo lists\n#r_echo<-matrix(c(rep(0,60)),nrow = 1)\nAR_echo<-matrix(c(rep(0,80)),nrow = 1)\nAL_echo<-matrix(c(rep(0,80)),nrow = 1)\nOR_echo<-matrix(c(rep(0,80)),nrow = 1)\nOL_echo<-matrix(c(rep(0,80)),nrow = 1)\n\n# make the first memory\nr_echo<-matrix(c(rep(0,80)),nrow = 1)\nr_echo<-add_noise(r_echo)\n\n# comment out if desired. just to normalize original echo\nr_echo<-r_echo/max(r_echo)\n\n# choose right or left randomly to begin\nturn<-sample(c(-1,1),1)\nturns<-c(turns,turn)\n\n# make the new_memory according to choice\nif (turn == -1){new_memory<-AL-r_echo\n}else{new_memory<-(AR+X)-r_echo}\n#new_memory<-ARX-r_echo\n\n# encode the memory with learning parameter\nfor (i in 1:length(new_memory)){\n  new_memory[i]<-rbern(1,learn)*new_memory[i]\n}\n#new_memory[1,]\n\nfor (j in 1:1000){\n#n_s<-new_similarity(new_memory[,1:40],AX[,1:40])\n#sum_echo<-sum_echo+(n_s^3)*new_memory\n\n  # fill echo lists with the raw echo from the new_memory\nAR_echo<-AR_echo+(((new_similarity(new_memory[,1:40],AR[,1:40]))^3)*new_memory)\nAL_echo<-AL_echo+(((new_similarity(new_memory[,1:40],AL[,1:40]))^3)*new_memory)\nOR_echo<-OR_echo+(((new_similarity(new_memory[,1:40],OR[,1:40]))^3)*new_memory)\nOL_echo<-OL_echo+(((new_similarity(new_memory[,1:40],OL[,1:40]))^3)*new_memory)\n\n# check if the light is present and normalize echos in the correct lists\n\nlight <- rbern(1,0.5)*2-1\nlight<-(1)\nlights<-c(lights,light)\n\nif (light == 1){\n  norm_echoR<-AR_echo/max(abs(AR_echo))\n  norm_echoL<-AL_echo/max(abs(AL_echo))\n} else{\n  norm_echoR<-OR_echo/max(abs(OR_echo))\n  norm_echoL<-OL_echo/max(abs(OL_echo))\n}\n\nsim_R<-sim_a(X[,61:80],norm_echoR[61:80])\nsim_L<-sim_a(X[,61:80],norm_echoL[61:80])\n\nsim_r_list<-c(sim_r_list,sim_R)\nsim_l_list<-c(sim_l_list,sim_L)\n\n# make a decision on right or left and go that way\n# if (abs(sim_R) < 0.1 && abs(sim_L) < 0.1){\n#   turn<-sample(c(-1,1),1)\n#   }else{\n#     if (sim_R*1000 > sim_L*1000){\n#       turn<-(1)\n#     } else{turn<-(-1)}\n#   }\nif (abs(sim_R-sim_L) < 0.1){\n  turn<-sample(c(-1,1),1)\n}else{\n  param<-sim_R-sim_L\n  if (abs(param)>1){param <- param/abs(param)}\n  if (sim_R>sim_L){\n    turn<-(rbern(1,(param))*2)-1\n  } else{turn<-(rbern(1,(-param))*(-2))+1}\n}\n\n  print(turn)\n  turns<-c(turns,turn)\n\n\n#sim_a(X[,41:60],norm_echoARX[41:60])\n\n\n\n## recall_listAR<-c(recall_listAR,sim_a(X[,41:60],norm_echoAR[41:60]))\n## recall_listAR<-c(recall_listAR,sim_a(X[,41:60],norm_echoAL[41:60]))\n## recall_listOR<-c(recall_listOR,sim_a(X[,41:60],norm_echoOR[41:60]))\n## recall_listOL<-c(recall_listOL,sim_a(X[,41:60],norm_echoOL[41:60]))\n\n# make new memory\nif (light == 1){\n  if (turn == 1){\n    new_memory<-(AR+X)-(add_noise(norm_echoR))\n  } else{\n    new_memory<-(AL)-(add_noise(norm_echoL))\n  }\n} else{\n  if (turn == 1){\n    new_memory<-(OR)-(add_noise(norm_echoR))\n  } else{\n    new_memory<-(OL+X)-(add_noise(norm_echoL))\n  }\n}\nfor (i in 1:length(new_memory)){\n  new_memory[i]<-rbern(1,learn)*new_memory[i]\n}\n  AR_echo<-AR_echo+(((new_similarity(new_memory[,1:40],AR[,1:40]))^3)*new_memory)\n  AL_echo<-AL_echo+(((new_similarity(new_memory[,1:40],AL[,1:40]))^3)*new_memory)\n  OR_echo<-OR_echo+(((new_similarity(new_memory[,1:40],OR[,1:40]))^3)*new_memory)\n  OL_echo<-OL_echo+(((new_similarity(new_memory[,1:40],OL[,1:40]))^3)*new_memory)\n  \n  # check if the light is present and normalize echos in the correct lists\n  \n  light <- rbern(1,0.5)*2-1\n  light<-(-1)\n  lights<-c(lights,light)\n  \n  if (light == 1){\n    norm_echoR<-AR_echo/max(abs(AR_echo))\n    norm_echoL<-AL_echo/max(abs(AL_echo))\n  } else{\n    norm_echoR<-OR_echo/max(abs(OR_echo))\n    norm_echoL<-OL_echo/max(abs(OL_echo))\n  }\n  \n  sim_R<-sim_a(X[,61:80],norm_echoR[61:80])\n  sim_L<-sim_a(X[,61:80],norm_echoL[61:80])\n  \n  sim_r_list<-c(sim_r_list,sim_R)\n  sim_l_list<-c(sim_l_list,sim_L)\n  \n  # make a decision on right or left and go that way\n  # if (abs(sim_R) < 0.1 && abs(sim_L) < 0.1){\n  #   turn<-sample(c(-1,1),1)\n  #   }else{\n  #     if (sim_R*1000 > sim_L*1000){\n  #       turn<-(1)\n  #     } else{turn<-(-1)}\n  #   }\n  if (abs(sim_R-sim_L) < 0.1){\n    turn<-sample(c(-1,1),1)\n  }else{\n    param<-sim_R-sim_L\n    if (abs(param)>1){param <- param/abs(param)}\n    if (sim_R>sim_L){\n      turn<-(rbern(1,(param))*2)-1\n    } else{turn<-(rbern(1,(-param))*(-2))+1}\n  }\n  \n  print(turn)\n  turns<-c(turns,turn)\n  \n  \n  #sim_a(X[,41:60],norm_echoARX[41:60])\n  \n  \n  \n  ## recall_listAR<-c(recall_listAR,sim_a(X[,41:60],norm_echoAR[41:60]))\n  ## recall_listAR<-c(recall_listAR,sim_a(X[,41:60],norm_echoAL[41:60]))\n  ## recall_listOR<-c(recall_listOR,sim_a(X[,41:60],norm_echoOR[41:60]))\n  ## recall_listOL<-c(recall_listOL,sim_a(X[,41:60],norm_echoOL[41:60]))\n  \n  # make new memory\n  if (light == 1){\n    if (turn == 1){\n      new_memory<-(AR+X)-(add_noise(norm_echoR))\n    } else{\n      new_memory<-(AL)-(add_noise(norm_echoL))\n    }\n  } else{\n    if (turn == 1){\n      new_memory<-(OR)-(add_noise(norm_echoR))\n    } else{\n      new_memory<-(OL+X)-(add_noise(norm_echoL))\n    }\n  }\n  for (i in 1:length(new_memory)){\n    new_memory[i]<-rbern(1,learn)*new_memory[i]\n  }\n}\n}\n\nturns[1:100]\nturns[101:200]\nturns[201:300]\nmean(turns[149:200])\nsim_r_list*100\nsim_l_list*100\nplot(1:2000,sim_l_list,ylim = c(0,1))\nplot(1:2000,sim_r_list,ylim = c(0,1))\n\n# length(recall_list)\nrecall_list2<-matrix(sim_r_list,ncol = 100)\nrecall_list2<-rowSums(recall_list2)\nplot(1:100,recall_list2/100,ylim = c(0,1))\nrecall_list3<-matrix(sim_l_list,ncol = 100)\nrecall_list3<-rowSums(recall_list3)\nplot(1:100,recall_list3/100,ylim = c(0,1))\nrecall_list2/100\nrecall_list3/100\nturns\nlights\ncor(turns,lights)\ndf<-data.frame(turns[2:2001], lights[2:2001],sim_l_list,sim_r_list)\ndf$x<-abs(df$turns.2.2001.*df$lights.2.2001.+1)/2\nsum(df$x)\n",
    "created" : 1486095013265.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2149228738",
    "id" : "590FDEEA",
    "lastKnownWriteTime" : 1491233755,
    "last_content_update" : 1491233755239,
    "path" : "C:/Users/Bradley/Dropbox/Bradley/MINERVA Ind Study/MINERVA/MINERVA2_separate functions.R",
    "project_path" : "MINERVA2_separate functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}