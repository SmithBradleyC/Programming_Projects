{
    "collab_server" : "",
    "contents" : "# Libraries needed\nlibrary(LaplacesDemon)\n\n# The number of items that each instance will have\nnum_items<-20\n\n# The number of distractor items\nnum_distractors<-500\n\n# The learning rate variable. Each individaul item in each instance has an L chance of being remembered. Otherwise =0\nL<-1\n\n# How many instances of each target item will be made\nitem1_rep<-9\nitem2_rep<-6\nitem3_rep<-3\n\n# Make each instance by randomly generating a string of items that are either -1 or 1\nitem1<-c((2*rbern(num_items,0.5)-1))\nitem2<-c((2*rbern(num_items,0.5)-1))\nitem3<-c((2*rbern(num_items,0.5)-1))\n\n# Make the distractor instances by randomly generating strings of items in a similar way to the items\ndistractors<-c()\ncount<-1\nrepeat {\n  distractors<-c(distractors,(2*rbern(num_items,0.5)-1))\n  if (count == num_distractors) {\n    break}\n  count<-count+1\n}\n\n# Put everything that will be in the memory into a list\nl_memory<-c(rep(item1,item1_rep),rep(item2,item2_rep),rep(item3,item3_rep),distractors)\n\n# For each item in memory assign items a value of 0 with probability 1-L\ncount<-1\nfor (num in l_memory){\n  l_memory[count]<-num*(rbern(1,L))\n  count<-count+1\n}\n\n# Make the memory into a matrix\nmemory<-matrix(data = l_memory,ncol = num_items, byrow = TRUE)\n\n# Make a probe matrix to test the recall of different items\nprobe<-matrix(c(item1,item2,item3,memory[item1_rep+item2_rep+item3_rep+1,],(2*rbern(num_items,0.5)-1),c(item1[1:(num_items/2)],rep(0,num_items/2))),ncol = 6)\n\n# get the intensity of each probe item by multiplying the memory matrix by the probe matrix, then dividing by the number of relevent items,\n# then raising each number to the third power, then summing across columns or adding up all trace intensities\n\ninten_data<-colSums(((memory%*%probe/num_items)^3))\n\n\n\n################################################################################################################################################\n#### new way to do dividing without matrix (I would like a simpler matrix way but....)\n\n# make a matrix as large as the resulting intensities matrix and fill it with the max relevant n's\ndivide<-matrix(data = c(rep(num_items,(nrow(memory)*ncol(probe)))),byrow = TRUE,ncol = ncol(probe))\n\n# for each probe\ncount_probe<-0\nwhile (count_probe < ncol(probe)){\n  count_probe<-count_probe+1\n  \n  # for each row in memory\n  count_row<-0\n  while (count_row < nrow(memory)){\n    count_row<-count_row+1\n    \n    # for each item in that row in memory\n    count_col<-0\n    while (count_col < ncol(memory)){\n      count_col<-count_col+1\n      \n      # if both the item in memory and the item in the probe are 0 then subtract 1 from the proper spot in the divide matrix\n      if (memory[count_row,count_col]==0){\n        if (probe[count_col,count_probe]==0){\n          divide[count_row,count_probe]<-divide[count_row,count_probe]-1\n        }\n      }\n    }\n  \n  }\n}\n\n# get the raw intensity matrix by multiplying the memory matrix by the probe matrix\ninten<-memory%*%probe\n\n# we now have a \"divide\" matrix of equal size to the intensity matrix. The \"divide\" matrix is full of the numbers that the\n# corresponding intensity matrix numbers need to be divided by\n\n# for each item in the intensity matrix divide by the corresponding \"divide\" matrix item\ncount<-0\nwhile (count < nrow(inten)*ncol(inten)){\n  count<-count+1\n  inten[count]<-inten[count]/divide[count]\n}\n\n# cube each item in the intensity matrix so that relevant items have more influence than less relevant items\ninten<-inten^3\n\n# sum the columns of the intensity matrix to get the overall intensity values for each probe\ninten_data<-colSums(inten)\n############################################################################################################################################\n\n# get the echo by multiplying the intensity matrix by the \necho<-t(inten)%*%memory\n\n# normalize the echo by dividing each row (probe result) by the largest number in that row\nnormed_echo<-echo\nnrow<-0\nwhile (nrow < nrow(normed_echo)){\n  nrow<-nrow+1\n  normed_echo[nrow,]<-normed_echo[nrow,]/max(abs(normed_echo[nrow,]))\n}\n\n# format data for output\nprobe_text<-apply(format(probe), 2, paste, collapse=\",\")\nround_normed_echo_text<-apply(format(round(normed_echo,digits = 0)), 1, paste, collapse=\",\")\nnormed_echo_text<-apply(format(round(normed_echo,digits = 2)), 1, paste, collapse=\",\")\necho_text<-apply(format(round(echo,digits = 2)), 1, paste, collapse=\",\")\n\n# output a table with probe, Rounded Echo, Normed Echo, Echo and Intensity for each probe.\nas.table(matrix(c(probe_text,round_normed_echo_text,normed_echo_text,echo_text, round(inten_data,digits = 3)), \n       nrow = 6, byrow = FALSE, \n       dimnames = list(c(\"Item 1\",\"Item 2\",\"Item 3\",\"Distractor\",\"Random\",\"Half Item 1\"),c(\"Probe\",\"Rounded Normed Echo\",\"Normed Echo\",\"Echo\",\"Intensity\"))))\n\n# sim<-(memory%*%probe2)/23\n# acti<-sim^3\n# inten<-sum(acti)\n# echo<-t(acti)%*%memory\n# normed<-echo/max(abs(echo))\n# sim\n# acti\n# inten\n# echo\n# normed",
    "created" : 1486138112183.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2848997363",
    "id" : "161FA7EF",
    "lastKnownWriteTime" : 1486826836,
    "last_content_update" : 1486826836,
    "path" : "~/Dropbox/Bradley/MINERVA Ind Study/MINERVA/MINERVA2.R",
    "project_path" : "MINERVA2.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}